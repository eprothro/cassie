#! ruby
require_relative '../lib/cassie'

def start
  runner = Cassie::Support::CommandRunner.new("cassandra")
  puts("Starting Cassandra...")
  runner.run
  runner.fail unless runner.finished?

  if runner.output =~ /state jump to NORMAL/
    puts "[#{green('✓')}] Cassandra Running"
  else
    runner.output.split("\n").grep(/ERROR/).each{|e| puts red("  " + e.gsub("; nested exception is:", "")) }
    puts "[#{red('✘')}] Cassandra Failed to Start"
  end
end

def stop(kill_all=false)
  runner = Cassie::Support::CommandRunner.new("ps", ["-awx"])
  runner.run!
 # | grep cassandra | grep -v grep | awk '{print $1}'`
  cassandra_awx = runner.output.split("\n").grep(/cassandra/)
  pids = cassandra_awx.map{ |p| p.split(' ').first.to_i }

  if pids.empty?
    puts red("No Cassandra process was found. Is Cassandra running?")
    exit(1)
  elsif pids.length > 1 && !kill_all
    puts red("Couldn't single out a Cassandra process.")
    puts red("  - Is cqlsh running?")
    puts red("  - Kill all cassandra processes with --all")
    cassandra_awx.each do |p|
      puts "    - #{p.split(' ').first.ljust(5,' ')} | #{p.split(' ').last}"
    end
    exit(1)
  end

  puts("Stopping Cassandra...")
  pids.each do|pid|
    Process.kill("TERM", pid)
    loop do
      sleep(0.1)
      begin
        Process.getpgid( pid )
      rescue Errno::ESRCH
        break
      end
    end
  end

  puts "[#{green('✓')}] Cassandra Stopped"
end

def kick
  stop
  start
end

def generate_config
  opts = {}
  if ARGV[1]
    opts[:destination_path] = if ARGV[1][0] == "/"
      # cassie configuration:generate /usr/var/my_config_dir/cassandra_db.yml
      ARGV[1]
    else
      # cassie configuration:generate my_config_dir/cassandra_db.yml
      File.join(Dir.pwd, ARGV[1])
    end
  end
  opts[:app_name]         = ARGV[2] if ARGV[2]

  generator = Cassie::Configuration::Generator.new(opts)
  generator.save
  puts "[✓] Cassandra configuration written to #{generator.destination_path}"
end

def dump_structure
  opts = {}
  opts[:destination_path] = Cassie.paths[:schema_structure]

  args = ["-e", "'DESCRIBE SCHEMA'"]

  runner = Cassie::Support::CommandRunner.new("cqlsh", args)
  runner.run!

  dir = File.dirname(opts[:destination_path])
  Dir.mkdir(dir) unless File.directory?(dir)
  File.open(opts[:destination_path], "w+") do |f|
    f.write(runner.output)
  end
  puts "[✓] Cassandra schema written to #{opts[:destination_path]}"
end

def tail_log
  runner = Cassie::Support::CommandRunner.new("which", ["cassandra"])
  runner.run!

  bin_path = runner.output.gsub("\n", '')
  log_path = bin_path.sub('bin/cassandra', 'logs/system.log')
  puts white("Tailing Cassandra system log, Ctrl-C to stop...")
  puts "  #{log_path}:\n\n"

  args = ['-f', log_path, '>', '/dev/tty']
  runner = Cassie::Support::CommandRunner.new("tail", args)
  runner.run!
end

def load_structure
  opts = {}
  opts[:source_path] = Cassie.paths[:schema_structure]

  args = ["-f", opts[:source_path]]

  runner = Cassie::Support::CommandRunner.new("cqlsh", args)
  runner.run!

  puts "[✓] Cassandra schema loaded from #{opts[:source_path]}"
end

def white(message)
  "\e[1;37m#{message}\e[0m"
end
def red(message)
  "\e[1;31m#{message}\e[0m"
end
def green(message)
  "\e[1;32m#{message}\e[0m"
end

case ARGV[0]
when "start"
  start
when "stop"
  stop(ARGV.include?('--all'))
when /kick|restart/
  kick
when /tail|log/
  tail_log
when "configuration:generate"
  generate_config
when "structure:dump"
  dump_structure
when "structure:load"
  load_structure
else
  puts red("`#{ARGV[0]}` is not a supported command.")
end