#! ruby
require_relative '../lib/cassie'

def start
  runner = Cassie::Support::CommandRunner.new("cassandra")
  puts("Starting Cassandra...")
  runner.run
  runner.fail unless runner.completed?

  if runner.output =~ /state jump to NORMAL/
    puts "[#{green('✓')}] Cassandra Running"
  else
    runner.output.split("\n").grep(/ERROR/).each{|e| puts red("  " + e.gsub("; nested exception is:", "")) }
    puts "[#{red('✘')}] Cassandra Failed to Start"
  end
end

def stop(kill_all=false)
  runner = Cassie::Support::CommandRunner.new("ps", ["-awx"])
  runner.run
  fail runner.failure_message unless runner.success?

  cassandra_awx = runner.output.split("\n").grep(/cassandra/)
  pids = cassandra_awx.map{ |p| p.split(' ').first.to_i }

  if pids.empty?
    puts red("No Cassandra process was found. Is Cassandra running?")
    exit(1)
  elsif pids.length > 1 && !kill_all
    puts red("Couldn't single out a Cassandra process.")
    puts red("  - Is cqlsh running?")
    puts red("  - Kill all cassandra processes with --all")
    cassandra_awx.each do |p|
      puts "    - #{p.split(' ').first.ljust(5,' ')} | #{p.split(' ').last}"
    end
    exit(1)
  end

  puts("Stopping Cassandra...")
  pids.each do|pid|
    Process.kill("TERM", pid)
    loop do
      sleep(0.1)
      begin
        Process.getpgid( pid )
      rescue Errno::ESRCH
        break
      end
    end
  end

  puts "[#{green('✓')}] Cassandra Stopped"
end

def kick
  stop
  start
end

def generate_config
  opts = {}
  if ARGV[1]
    opts[:destination_path] = if ARGV[1][0] == "/"
      # cassie configuration:generate /usr/var/my_config_dir/cassandra_db.yml
      ARGV[1]
    else
      # cassie configuration:generate my_config_dir/cassandra_db.yml
      File.join(Dir.pwd, ARGV[1])
    end
  end
  opts[:app_name]         = ARGV[2] if ARGV[2]

  generator = Cassie::Configuration::Generator.new(opts)
  generator.save
  puts "[✓] Cassandra configuration written to #{generator.destination_path}"
end

def dump_structure
  dumper = Cassie::Migration::StructureDumper.new
  dumper.dump
  puts "[#{green("✓")}] Cassandra schema written to #{dumper.destination_path}"

rescue => e
  puts e.message
  exit(1)
end

def load_structure
  loader = Cassie::Migration::StructureLoader.new
  loader.load
  puts "[#{green("✓")}] Cassandra schema loaded from #{loader.source_path}"

rescue => e
  puts e.message
  exit(1)
end

def tail_log
  runner = Cassie::Support::CommandRunner.new("which", ["cassandra"])
  runner.run!

  bin_path = runner.output.gsub("\n", '')
  log_path = bin_path.sub('bin/cassandra', 'logs/system.log')
  puts white("Tailing Cassandra system log, Ctrl-C to stop...")
  puts "  #{log_path}:\n\n"

  args = ['-f', log_path, '>', '/dev/tty']
  runner = Cassie::Support::CommandRunner.new("tail", args)
  runner.run!
end

# Use current schema to initialize versioned migrations
#   * import current schema as initial migration
#   * initialize cassie_schema keyspace and version table
#   * insert initial version
#   * dump structure
def initialize_migrations
  Cassie::Migration.initialize_versioning
  puts "[#{green("✓")}] Versioned migrations initialized. Current version: #{Cassie::Migration.version_number}"
rescue Cassie::Migration::AlreadyInitiailizedError
  puts "[#{red('✘')}] Versioned migration metatdata already exists. Current version: #{Cassie::Migration.version_number}"
rescue => e
  puts e.message
  exit(1)
end

def schema_history
  print_versions(Cassie::Migration.versions)
rescue Cassie::Migration::UninitializedError => e
  puts red(e.message)
end

def schema_version
  print_versions([Cassie::Migration.version])
rescue Cassie::Migration::UninitializedError => e
  puts red(e.message)
end

def print_versions(versions)
  require 'terminal-table'
  members = [:version_number, :description, :migrator, :migrated_at]
  titles  = ['Version', 'Description', 'Migrated by', 'Migrated at']
  table = Terminal::Table.new(headings:  titles)
  versions.each.with_index do |v, i|
    v.version_number = "* #{v.version_number}" if i == 0
    table.add_row(v.to_h.values_at(*members))
  end
  table.align_column(0, :right)
  puts table
end

def white(message)
  "\e[1;37m#{message}\e[0m"
end
def red(message)
  "\e[1;31m#{message}\e[0m"
end
def green(message)
  "\e[1;32m#{message}\e[0m"
end

case ARGV[0]
when "start"
  start
when "stop"
  stop(ARGV.include?('--all'))
when /kick|restart/
  kick
when /tail|log/
  tail_log
when "configuration:generate"
  generate_config
when "structure:dump"
  dump_structure
when "structure:load"
  load_structure
when /migrations?\:initialize/
  initialize_migrations
when "schema:history"
  schema_history
when "schema:version"
  schema_version
else
  puts red("`#{ARGV[0]}` is not a supported command.")
end