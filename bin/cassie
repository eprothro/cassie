#! ruby
require_relative '../lib/cassie'

def start
  runner = Cassie::Support::CommandRunner.new("cassandra")
  puts("Starting Cassandra...")
  runner.run
  runner.fail unless runner.completed?

  if runner.output =~ /state jump to NORMAL/
    puts "[#{green('✓')}] Cassandra Running"
  else
    runner.output.split("\n").grep(/ERROR/).each{|e| puts red("  " + e.gsub("; nested exception is:", "")) }
    puts "[#{red('✘')}] Cassandra Failed to Start"
  end
end

def stop(kill_all=false)
  runner = Cassie::Support::CommandRunner.new("ps", ["-awx"])
  runner.run
  fail runner.failure_message unless runner.success?

  cassandra_awx = runner.output.split("\n").grep(/cassandra/)
  pids = cassandra_awx.map{ |p| p.split(' ').first.to_i }

  if pids.empty?
    puts red("No Cassandra process was found. Is Cassandra running?")
    exit(1)
  elsif pids.length > 1 && !kill_all
    puts red("Couldn't single out a Cassandra process.")
    puts red("  - Is cqlsh running?")
    puts red("  - Kill all cassandra processes with --all")
    cassandra_awx.each do |p|
      puts "    - #{p.split(' ').first.ljust(5,' ')} | #{p.split(' ').last}"
    end
    exit(1)
  end

  puts("Stopping Cassandra...")
  pids.each do|pid|
    Process.kill("TERM", pid)
    loop do
      sleep(0.1)
      begin
        Process.getpgid( pid )
      rescue Errno::ESRCH
        break
      end
    end
  end

  puts "[#{green('✓')}] Cassandra Stopped"
end

def kick
  stop
  start
end

def generate_config
  opts = {}
  if ARGV[1]
    opts[:destination_path] = if ARGV[1][0] == "/"
      # cassie configuration:generate /usr/var/my_config_dir/cassandra_db.yml
      ARGV[1]
    else
      # cassie configuration:generate my_config_dir/cassandra_db.yml
      File.join(Dir.pwd, ARGV[1])
    end
  end
  opts[:app_name]         = ARGV[2] if ARGV[2]

  generator = Cassie::Configuration::Generator.new(opts)
  generator.save
  puts "[✓] Cassandra configuration written to #{generator.destination_path}"
end

def dump_structure
  dumper = Cassie::Schema::StructureDumper.new
  dumper.dump
  puts "[#{green("✓")}] Cassandra schema written to #{dumper.destination_path}"

rescue => e
  puts e.message
  exit(1)
end

def load_structure
  loader = Cassie::Schema::StructureLoader.new
  loader.load
  puts "[#{green("✓")}] Cassandra schema loaded from #{loader.source_path}"

rescue => e
  puts e.message
  exit(1)
end

def tail_log
  runner = Cassie::Support::CommandRunner.new("which", ["cassandra"])
  runner.run!

  bin_path = runner.output.tr("\n", '')
  log_path = bin_path.sub('bin/cassandra', 'logs/system.log')
  puts white("Tailing Cassandra system log, Ctrl-C to stop...")
  puts "  #{log_path}:\n\n"

  args = ['-f', log_path, '>', '/dev/tty']
  runner = Cassie::Support::CommandRunner.new("tail", args)
  runner.run!
end

# Use current schema to initialize versioned migrations
#   * import current schema as initial migration
#   * initialize cassie_schema keyspace and version table
#   * insert initial version
#   * dump structure
def initialize_migrations
  Cassie::Schema.initialize_versioning
  puts "[#{green("✓")}] Versioned migrations initialized. Current version: #{Cassie::Schema.version_number}"
rescue Cassie::Schema::AlreadyInitiailizedError
  puts "[#{red('✘')}] Versioned migration metatdata already exists. Current version: #{Cassie::Schema.version_number}"
rescue => e
  puts e.message
  exit(1)
end

def schema_history
  print_versions(Cassie::Schema.versions)
rescue Cassie::Schema::UninitializedError => e
  puts red(e.message)
end

def schema_version
  print_versions([Cassie::Schema.version])
rescue Cassie::Schema::UninitializedError => e
  puts red(e.message)
end

def create_migration(name, bump_type)
  version = Cassie::Schema.next_version(bump_type)
  version.description = name
  puts("Creating migration for schema version #{version.number}")
  begin
    writer = Cassie::Schema::Migration::Writer.new(version)
    writer.write
    rel_path = writer.filename.sub(Dir.pwd, "")
    puts green("  create #{rel_path}")
  rescue IOError => e
    puts red(e.message)
  end
end

def migrate(version)

  migrator = Cassie::Schema::Migration::Migrator.new(version)

  migrator.before_each = Proc.new do |migration, direction|
    puts "-- Migragting #{migration.direction}: #{migration.version.number}"
  end

  migrator.after_each = Proc.new do |migration, duration|
    puts "-- done (#{duration} ms)"
  end

  if migrator.migrations.count == 0
    if migrator.target == migrator.current
      puts "Already at #{migrator.target}, no migrations to process..."
    else
      puts "No migrations found to migrate to #{migrator.target}, staying at #{migrator.current}"
    end
  else
    puts "Migrating #{migrator.direction} to schema version #{migrator.target.number}:"
    migrator.migrate
    puts "\nMigration complete. Schema is at #{migrator.target.number}"
  end
end

def print_versions(versions)
  require 'terminal-table'
  members = [:number, :description, :migrator, :migrated_at]
  titles  = ['Number', 'Description', 'Migrated by', 'Migrated at']
  table = Terminal::Table.new(headings:  titles)

  versions.each.with_index do |v, i|
    row = v.to_h.values_at(*members)
    row[0] = "* #{row[0]}" if i == 0
    table.add_row(row)
  end

  table.align_column(0, :right)
  puts table
end

def white(message)
  "\e[1;37m#{message}\e[0m"
end
def red(message)
  "\e[1;31m#{message}\e[0m"
end
def green(message)
  "\e[1;32m#{message}\e[0m"
end

args = ARGV.dup.select{|a| a !~ /^--/ }
opts = ARGV.dup.select{|a| a =~ /^--/ }
cmd = args.delete_at(0)

Cassie.logger.level = ::Logger::WARN unless opts.include?('--debug')

case cmd
when "start"
  start
when "stop"
  stop(opts.include?('--all'))
when /kick|restart/
  kick
when /tail|log/
  tail_log
when "configuration:generate"
  generate_config
when "structure:dump"
  dump_structure
when "structure:load"
  load_structure
when /migrations?\:initialize/
  initialize_migrations
when "schema:history"
  schema_history
when "schema:version"
  schema_version
when "migration:create"
  bump = nil
  bump = :minor if opts.delete('--minor')
  bump = :major if opts.delete('--major')
  bump = :patch if opts.delete('--patch')
  bump = :build if opts.delete('--build')

  create_migration(args.first, bump)
when "migrate"
  migrate(args.first)
else
  puts red("`#{cmd}` is not a supported command.")
end